#!/bin/bash

# Matheus Fillipe --- 25/01/2022
# wcofun.com scraper MIT

##########################################################################################
# Things you might want to change:

# MENU_CMD. Choose your menu.
# NOTIFY_CMD. How to tell you about the status. Leave empty for a simple echo to stdout
 if [ -t 0 ] # if on a terminal
 then 
  MENU_CMD="fzf"
  NOTIFY_CMD=""
else
  MENU_CMD="rofi -dmenu -i"
  # MENU_CMD="dmenu"
  NOTIFY_CMD="notify-send WCOFUN"
 fi

# User agent. Maybe you have problems with this
UA="User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:96.0) Gecko/20100101 Firefox/96.0"

# Maybe you want to use a proxy? (Helps when getting blocked by cloudflare, or if you want to debug)
CURL_EXTRA_PARAMS=""
# CURL_EXTRA_PARAMS="-k --tlsv1 -x http://localhost:8080"
PRE_COMMAND=""
# PRE_COMMAND="mitmdump 2>&1 /dev/null"

# if the config file exists, it will override the variables above
if [ -f ~/.wcofunrc ]
then
  echo "Loading config file ~/.wcofunrc"
  source ~/.wcofunrc
fi

##########################################################################################

baseurl="https://www.wcofun.com/"
domainname="www.wcofun.com"

storage="$HOME/.local/share/wcofun.cli/"

get_cache () {
  if [ ! -f "$1" ]; then
    echo '{}' > "$1"
  fi
  cat "$1"
}

get_cache_search () {
  get_cache "$storage/search.json"
}

get_cache_episode () {
  get_cache "$storage/episode.json"
}

save_cache() {
  echo "$1" > "$2"
}

save_cache_search () {
  save_cache "$1" "$storage/search.json"
}

save_cache_episode () {
  save_cache "$1" "$storage/episode.json"
}


finalize (){
  [ -n "$PRE_COMMAND" ] && kill %1
  exit 0
}

mkdir -p "$storage"
trap finalize INT

menu_cmd () {
  case "$MENU_CMD" in
    "fzf"*)
      args=$(echo "$*" | sed -re 's/""(.+)""/"\1"/g')
      eval "$MENU_CMD $args"
      ;;
    "rofi"*)
      args=${*//--prompt/-p}
      args=${args//--query/-filter}
      args=$(echo "$args" | sed -re 's/""(.+)""/"\1"/g')
      eval "$MENU_CMD $args"
      ;;
    "dmenu"*)
      args=${*//--prompt/-p}
      args=${args//--print-query/}
      args=${args//--query \"*\"/}
      args=$(echo "$args" | sed -re 's/""(.+)""/"\1"/g')
      eval "$MENU_CMD $args"
      ;;
    *)
      echo "Warning: Unknown menu command: $MENU_CMD"
      eval "$MENU_CMD $*"
      ;;
  esac
}

notify_cmd () {
  echo "$*"
  if [ -n "$NOTIFY_CMD" ]; then
    $NOTIFY_CMD "$1"
  fi
}


chru() { printf "\x$(printf %x "$1")"; }

get_link() {
  link=$1
  script=$(
  curl --silent $CURL_EXTRA_PARAMS "$link" -H "$UA" --compressed | htmlq 'body > div:nth-child(3) > div.twelve.columns > div > div.fourteen.columns > div:nth-child(7) > script:nth-child(2)' | sed 's/<script>\(.*\)<\/script>/\1/')
  offset=$(echo "$script" | sed 's/.*- \([0-9]*\).*).*/\1/')

  innerscript=$(
  echo "$script" | cut -d "[" -f2 | cut -d "]" -f1 | tr "," "\n" | while read -r LINE; do
    n=$(echo "$LINE" | tr -d \" | base64 --decode | sed 's/[^[:digit:]]//g')
    n=$((n - offset))
    printf "%s" "$(chru $n)"
  done
  )

  url=$baseurl$(echo "$innerscript" | sed 's/^.*src="\([^"]*\)".*$/\1/')
  url=$baseurl$(curl --silent $CURL_EXTRA_PARAMS "$url" -H "$UA" | grep "$.getJSON" | sed 's/^.*"\(.*\)".*$/\1/')

  curl --silent $CURL_EXTRA_PARAMS  "$url" \
    -H "authority: $domainname" \
    -H 'pragma: no-cache' \
    -H 'cache-control: no-cache' \
    -H 'accept: application/json, text/javascript, */*; q=0.01' \
    -H "$UA" \
    -H 'x-requested-with: XMLHttpRequest' \
    -H 'sec-gpc: 1' \
    -H 'sec-fetch-site: same-origin' \
    -H 'sec-fetch-mode: cors' \
    -H 'sec-fetch-dest: empty' \
    -H "Referer: $baseurl" \
    -H 'accept-language: en-US,en;q=0.9' \
    --compressed | jq -r '(.cdn + "/getvid?evid=" + .enc)'
}

get_num() {
  echo "$1" | sed -re 's/^"*([[:digit:]]+)>.*$/\1/g'
}

download () {
  curl "$1" \
    -H 'Connection: keep-alive' \
    -H "$UA" \
    -H 'Accept: */*' \
    -H 'Sec-GPC: 1' \
    -H 'Sec-Fetch-Site: cross-site' \
    -H 'Sec-Fetch-Mode: no-cors' \
    -H 'Sec-Fetch-Dest: video' \
    -H "Referer: $baseurl" \
    -H 'Accept-Language: en-US,en;q=0.9' \
    -H 'Range: bytes=0-' \
    --compressed --output "$2"
  if [ $? -ne 0 ]; then
    notify_cmd "Error: failed to get video"
  fi
}

stream () {
  curl "$1" \
    -H 'Connection: keep-alive' \
    -H "$UA" \
    -H 'Accept: */*' \
    -H 'Sec-GPC: 1' \
    -H 'Sec-Fetch-Site: cross-site' \
    -H 'Sec-Fetch-Mode: no-cors' \
    -H 'Sec-Fetch-Dest: video' \
    -H "Referer: $baseurl" \
    -H 'Accept-Language: en-US,en;q=0.9' \
    -H 'Range: bytes=0-' \
    --compressed | mpv -
  if [ $? -ne 0 ]; then
    notify_cmd "Error: failed to get video"
  fi
}

search () {
  list=$(
    curl --silent $CURL_EXTRA_PARAMS "$baseurl/search" \
    -X POST -H "$UA" \
    -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8' \
    -H 'Accept-Language: en-US,en;q=0.5' \
    -H 'Accept-Encoding: gzip, deflate' \
    -H 'Content-Type: application/x-www-form-urlencoded' \
    -H "Origin: $baseurl" \
    -H 'Connection: keep-alive' \
    -H "Referer: $baseurl/search" \
    -H 'Upgrade-Insecure-Requests: 1' \
    -H 'Sec-Fetch-Dest: document' \
    -H 'Sec-Fetch-Mode: navigate' \
    -H 'Sec-Fetch-Site: same-origin' \
    -H 'Sec-Fetch-User: ?1' \
    -H 'Pragma: no-cache' \
    -H 'Cache-Control: no-cache' \
    -H 'TE: trailers' \
    --data-raw "catara=${1// /+}&konuara=series" \
    --compressed | htmlq "div.img"
  )
  titles=$(echo "$list" | htmlq 'img' -a alt)
 
  if [ -z "$titles" ]; then
    exit 1
  fi

  anime=${1//-/_}
  lastq="$(get_cache_search | jq '.'"${anime// /_}"'')"
  if [ "$lastq" == "null" ]; then
    choosen=$(echo "$titles" | awk '{print NR  "> " $0}' | menu_cmd) 
  else
    choosen=$(echo "$titles" | awk '{print NR  "> " $0}' | menu_cmd --query \""$lastq"\" )
  fi

  if [ -z "$choosen" ]; then
    return
  fi

  save_cache_search "$(get_cache_search | jq '.'"${anime// /_}"' = "'"$choosen"'"')"
  n=$(get_num "$choosen")
  echo "$list" | htmlq 'a' -a href | awk 'NR=='"$n"
}

choose_ep () {
  list=$(curl --silent $CURL_EXTRA_PARAMS "$1" \
  -H "authority: $domainname" \
  -H 'pragma: no-cache' \
  -H 'cache-control: no-cache' \
  -H 'upgrade-insecure-requests: 1' \
  -H "$UA" \
  -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9' \
  -H 'sec-gpc: 1' \
  -H 'sec-fetch-site: none' \
  -H 'sec-fetch-mode: navigate' \
  -H 'sec-fetch-user: ?1' \
  -H 'sec-fetch-dest: document' \
  -H 'accept-language: en-US,en;q=0.9' \
  --compressed | htmlq '#sidebar_right3 a' | tac)
  titles=$(echo "$list" | htmlq 'a' -a title)

  if [ -z "$titles" ]; then
    exit 1
  fi

  choosen_anime=${1##*/}
  choosen_anime=${choosen_anime//-/_}
  lastq="$(get_cache_episode | jq '.'"$choosen_anime"'')"
  if [ "$lastq" == "null" ]; then
    choosen=$(echo "$titles" | awk '{print NR  "> " $0}' | menu_cmd) 
  else
    n=$(get_num "$lastq")
    # n=$((n + 1))
    n="$n>"
    choosen=$(echo "$titles" | awk '{print NR  "> " $0}' | menu_cmd --query \""$n"\" )
  fi

  if [ -z "$choosen" ]; then
    return
  fi

  save_cache_episode "$(get_cache_episode | jq '.'"$choosen_anime"' = "'"$choosen"'"')"
  n=$(get_num "$choosen")
  echo "$list" | htmlq 'a' -a href | awk 'NR=='"$n"
}

all_eps () {
  curl --silent CURL_EXTRA_PARAMS "$1" \
  -H "authority: $domainname" \
  -H 'pragma: no-cache' \
  -H 'cache-control: no-cache' \
  -H 'upgrade-insecure-requests: 1' \
  -H "$UA" \
  -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9' \
  -H 'sec-gpc: 1' \
  -H 'sec-fetch-site: none' \
  -H 'sec-fetch-mode: navigate' \
  -H 'sec-fetch-user: ?1' \
  -H 'sec-fetch-dest: document' \
  -H 'accept-language: en-US,en;q=0.9' \
  --compressed | htmlq '#sidebar_right3 a ' | tac
}

help() {
   echo "wcofun.cli"
   echo
   echo "Syntax: "
   echo "Search and stream or download one episode: wcofun [search query]"
   echo "Download all episodes: wcofun -d [search query]"
   echo
}

main () {
  if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    help
    exit 0
  fi

  if [ -n "$PRE_COMMAND" ]
  then
    $PRE_COMMAND & 
    sleep 2
  fi

  # If first argument is -d, download all episodes
  download=false
  if [ "$1" = "-d" ]; then
    shift
    download=true
  fi

  query="$*"
  query_file="$storage/lastq"
  if [ -z "$query" ]; then
    lastq=$(head -n 1 "$query_file")
    if [ -z "$lastq" ]; then
      query=$(cat "$query_file" 2>/dev/null | menu_cmd --prompt \"Search query: \" --print-query | head -1)
    else
      query=$(cat "$query_file" 2>/dev/null | menu_cmd --prompt \"Search query: \" --query \""$lastq"\" --print-query | head -1)
    fi
  fi
  currentq=$(printf '%s\n%s' "$query" "$(cat "$query_file" 2>/dev/null)")
  echo "$currentq" | sed -re '/^[[:space:]]*$/d' >> "$query_file.tmp"
  awk '!x[$0]++' "$query_file.tmp" > "$query_file"
  rm "$query_file.tmp"
  echo "Searching for: $query"

  anime=$(search "$query")
  if [ -z "$anime" ]; then
    notify_cmd "No results for: $query"
    [ -n "$PRE_COMMAND" ] && kill %1
    exit 1
  fi
  echo "Selected anime: $anime"

  # Download all episodes
  if [ "$download" = true ]; then
    [ -n "$PRE_COMMAND" ] && kill %1
    folder="${query// /_}"
    mkdir -p "$folder"
    notify_cmd "Downloading all episodes to: $folder"
    echo 
    echo
    all_eps "$anime" | while read -r line; do
      ep=$(echo "$line" | htmlq 'a' -a href)
      title=$(echo "$line" | htmlq 'a' -a title)
      echo "Downloading: $title"
      echo "Episode url: $ep"
      url=$(get_link "$ep")
      echo "Got link: $url"
      download "$url" "$folder/$title.mp4"
    done
    notify_cmd "Download finished: $folder"
    exit 0
  fi

  ep=$(choose_ep "$anime")
  if [ -z "$ep" ]; then
    [ -n "$PRE_COMMAND" ] && kill %1
    exit 1
  fi
  echo "Selected episode: $ep"

  opt=$(printf "%s\n%s" "Stream" "Download" | menu_cmd)
  notify_cmd "Fetching video url..."
  url=$(get_link "$ep")
  echo "Got url: $url"

  [ -n "$PRE_COMMAND" ] && kill %1
  case $opt in
    Stream)
      notify_cmd "Starting stream..."
      stream "$url"
      ;;
    Download)
      filename=$(echo " " | menu_cmd --prompt \"Save Path: \" --query \""${ep##*/}.mp4"\" --print-query)
      if [ -z "$filename" ]; then
        notify_cmd "Canceled."
        exit 0
      fi
      notify_cmd "Downloading to: $filename"
      download "$url" "$filename"
      notify_cmd "Download finished: $filename"
      ;;
  esac
}

main "$@"
